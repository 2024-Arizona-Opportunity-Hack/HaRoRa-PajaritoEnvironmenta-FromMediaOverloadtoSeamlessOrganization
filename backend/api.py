from fastapi import FastAPI, File, UploadFile, HTTPException, Form
from fastapi.middleware.cors import CORSMiddleware
from typing import List
import uuid
import imghdr
from queue import Queue

app = FastAPI()
file_queue = Queue()

# Allow Cross-Origin Resource Sharing (CORS)
origins = [
    "http://localhost",
    "http://localhost:5173",  # example frontend
    "http://peec.harora.lol"  # replace with your frontend domain
    "https://peec.harora.lol"  # replace with your frontend domain
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # Allows specified origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods (GET, POST, PUT, etc.)
    allow_headers=["*"],  # Allows all headers
)

# Dummy data
data = {
    "files": [],
    "tags": {}
}

# Helper function to validate image file types
def validate_image(file: UploadFile):
    valid_image_formats = {"jpeg", "png", "gif", "bmp", "jpg"}
    # Check the file type using the imghdr module
    file_type = imghdr.what(file.file)
    if file_type not in valid_image_formats:
        raise HTTPException(status_code=400, detail="Invalid image format")
    return file_type



@app.post("/upload")
async def upload_images(files: List[UploadFile] = File(...), tags: str = Form(...)) -> dict:
    uploaded_files: List[dict] = []
    for file in files:
        try:
            file_type: str = validate_image(file)
        except HTTPException as e:
            return e.detail

        file_id: str = str(uuid.uuid4())
        file_data: dict = {"id": file_id, "name": file.filename, "type": file_type, "tags": tags}
        data["files"].append(file_data)
        uploaded_files.append({"file_id": file_id, "name": file.filename, "type": file_type, "tags": tags})

        # store the file in /tmp dir
        file_location = f"/tmp/{file_id}.{file_type}"
        with open(file_location, "wb") as buffer:
            buffer.write(await file.read())
        file_queue.put(file_location)

    # Store tags
    for tag in tags.split(","):
        tag = tag.strip()
        if tag in data["tags"]:
            data["tags"][tag].append(file_id)
        else:
            data["tags"][tag] = [file_id]

    return {"uploaded_files": uploaded_files}


# GET /search
@app.get("/search")
async def search_files(query: str = None):
    if query:
        result = [file for file in data["files"] if query.lower() in file["name"].lower()]
    else:
        result = data["files"]
    return {"result": result}

# GET /tag/{uuid}
@app.get("/tag/{file_id}")
async def get_tags(file_id: str):
    tags = data["tags"].get(file_id, [])
    return {"file_id": file_id, "tags": tags}

# PUT /tag/{uuid}
@app.put("/tag/{file_id}")
async def update_tags(file_id: str, tags: List[str]):
    data["tags"][file_id] = tags
    return {"message": "Tags updated successfully", "file_id": file_id, "tags": tags}


# ===
# File Processing
# ===
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Any
from uuid import UUID
import threading
import time
import process as image_processor

@dataclass
class ImageDetail:
    url: str  # TODO: get dropbox url (for now uses local file storage)
    title: str  # generated by llama
    caption: str  # generated by llama
    tags: str  # generated by llama
    embedding_vector: list[float]  # Assuming a list to hold the vector
    coordinates: str  # from metadata
    capture_time: datetime # from metadata
    extended_meta: Any  # from metadata
    season: str # from capture date


def process_file(file_path: str):
  # Simulate file processing delay
  url = file_path # TODO: change to dropbox url 

  # get title, caption and tags
  while True:
    img_details = image_processor.get_image_captioning(file_path)
    if img_details is None:
      print('get_image_captioning returned None')
      continue
    title = img_details['title']
    caption = img_details['image_description']
    tags = ','.join(img_details['tags'])
    break

  # trying to get image embedding
  while True:
    embedding_vector = image_processor.get_image_embedding(file_path)
    if embedding_vector is None:
      print('get image embedding returned None')
      continue
    break

  # extract_image_metadata
  img_metadata = image_processor.extract_image_metadata(file_path)
  # TODO: how to pass lat lon?
  # TODO: how to pass captured date?


  time.sleep(2)
  print(f"Processed file: {file_path}")

def file_processor():
  while True:
    if not file_queue.empty():
      file_path = file_queue.get()
      process_file(file_path)
    else:
      time.sleep(1)

# Start a background thread for processing files
threading.Thread(target=file_processor, daemon=True).start()


if __name__ == '__main__':
    import uvicorn
    uvicorn.run('api:app', host='localhost', port=8080, reload=True)

